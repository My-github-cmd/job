 ```
    // 上面的代码等效于下面的代码
    var a = [],i; 
    for(i=0;i<10;i++){
        a[i] = function (){
            console.log(i)
        }
    }
 ```
 * 一： 结果为10，原因：全局变量数组a每个元素保存着一个匿名函数，变量i使用了var定义，var定义的变量会发生变量的提升，最终变为了全局变量，所以每循环一次，i的值就加1，循环结束i的值已经变为了10，所以，循环结束后无论数组那个元素的匿名函数发生调用，得到的结果都是10

 * 二：结果报错，let声明的变量有自己的块级作用域，let重新声明了tep变量，tep变量只能在let作用域中使用，let不会变量声明的提升，使用let声明的变量必须要先声明再使用，否则报错

 * 三：数组最小值:
    ```
    var arr = [1,4,6,2,7]
    console.log(Math.min(...arr))
    ```

 * 四：var声明的变量会挂在在window下，没有自己的作用域，会变量声明的提升，可以声明同名变量；let声明的变量有自己的作用域，无变量声明的提升，不可以声明同名变量，必须先声明再使用；const声明的变量必须赋初值，先声明再使用，不能用null占位，声明后变量值不可以修改

 * 五：结果：20；obj.fn(),obj调用了fn()方法，所以tihs执向obj，this.name 拿到的就是对象obj里面的name

 * 六：可以为对象创建独一无二的key值；可以使用symbol替代常量；使用symbol定义类的私有属性/方法等

 * 七：浅拷贝和深拷贝
    浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用
    深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”

 * 八：TypeScript是 JavaScript 的超集，包含了 JavaScript 的所有元素，在TypeScript中可以运行JavaScript代码

 * 九：typescript优点：增加代码的可读性和可维护性，js文件可以直接命名为ts文件；缺点：新增了接口，泛型，类等，学习成本增加；短期开发增加开发成本

 * 十：引用计数用来记录当前有多少指针指向同一块动态分配的内存。当有指针指向这块内存时，计数器加1；当指向此内存的指针销毁时，计数器减1。当引用计数为0时，表示此块内存没有被任何指针指向，此块被共享的动态内存才能被释放。
 优点：实时性：一旦没有引一用，内存就直接释放了。不⽤像其他机制等到特定 时机。实时性还带来个好处：处理回收内存的时间分摊到了平时
 缺点：维护引计数消耗资源；循环引用问题，某个变量互相引用，如果不存在其它对象对它们的引用，技术仍然为1，占用的内存永远不会被释放回收

 * 十一：分为标记和整理两个阶段：首先标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。优点：减少碎片化空间；缺点：不会立即回收垃圾对象，移动对象位置，回收效率慢

 * 十二：用于存活时间较短的对象。在64为操作系统又32MB的空间，32为操作系统有16MB的空间，新生代又分为两个空间form和to空间。Scavenge GC算法：当from空间被沾满时，启动GC算法。将存活的对象从from空间中转移到to空间；清空from空间；from space 与 to space 互换；完成一次新生代GC

 * 十三：
      原理：它是在V8清除老生代对象时为提高清除效率优化时使用的，因为在进行垃圾回收的操作时会阻塞程序的执行，所以在老生代中会在程序执行的空档期去执行回收操作，此时就可以使用增量标记算法。它是将当前一整段的垃圾回收操作，分成多个小步组合去完成，实现垃圾回收和程序执行交替完成，可以让时间消耗更合理，达到效率优化的好处
       1.JS程序执行过程中，会伴随着垃圾回收的工作
       2.当垃圾回收工作时，需要遍历对象进行标记，此时不需要将所有对象进行标记，可以先将直接可达的对象进行标记，标记完成后暂停标记
       3.然后让JS程序执行一会，再让GC机制去做二步标记，将间接可达的对象进行标记，标记完成后暂停标记
       4.重复以上两不操作，让程序执行和垃圾回收的标记操作交替执行，来达到优化效率和提升用户体验的目的
       5.直到标记全部完成后，执行垃圾回收